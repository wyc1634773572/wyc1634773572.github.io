<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[c++随笔]变量类型</title>
    <link href="/2024/12/19/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/12/19/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>数据类型</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>char</td><td>1（字节）</td><td>1</td></tr><tr><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>unsigned int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>8</td></tr><tr><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>long long</td><td>8</td><td>8</td></tr><tr><td>指针</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><p>重要且易混淆的sizeof：<br>sizeof()计算的是所占字节的大小，即上表中所列举出的数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> b[<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> *c = b;<br><span class="hljs-comment">//sizeof对上面进行求值：</span><br><span class="hljs-built_in">sizeof</span>(a) = <span class="hljs-number">20</span> <span class="hljs-comment">//数组有五个元素，每个占4字节</span><br><span class="hljs-built_in">sizeof</span>(b[<span class="hljs-number">0</span>]) = <span class="hljs-number">4</span> <span class="hljs-comment">//一个int大小</span><br><span class="hljs-built_in">sizeof</span>(c) = <span class="hljs-number">4</span> <span class="hljs-comment">//c是指针</span><br></code></pre></td></tr></table></figure><p>注意，虽然我们平常总说数组名可以看作一个指针，但是这里sizeof(a)并不能这样来看，只有当数组名作传参时，才会被认为是指针，而sizeof()实际上是个运算符。数组传参时，均会退化为指向首元素地址：&amp;a[0]这样的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;wone&quot;</span>;<br>a++;<span class="hljs-comment">//这样做会编译报错</span><br><span class="hljs-built_in">fun</span>(a);<span class="hljs-comment">//func(char ch[])&#123;ch++;&#125;此时通过一个函数进行a++就能正常编译，说明数组已经退化为指针了</span><br></code></pre></td></tr></table></figure><p>数组退化为指针之于代码的一些影响：很多时候我们遇到的一些接口会将数组还有数组长度一同作为参数传入，这为什么呢？明明只要有数组名，就可以通过sizeof(arr) &#x2F; sizeof(arr[0])来求得长度，为什么还要再浪费一个参数空间来传入一个可以计算出来的值？因为数组传参时，在函数内部退化为了指针，无法再用sizeof求得其长度。自己设计接口时也要注意这点。</p><p>数组与指针在传参时是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_point</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *arr)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(*arr != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        std::cout &lt;&lt; *arr &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        arr++;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_arr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> arr[], <span class="hljs-type">int</span> arr_len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;arr_len; i++)&#123;<br>        std::cout&lt;&lt;arr[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-comment">//将指针传入指针参数</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">test_point</span>(str);<br>    &#125;<br>    &#123;<span class="hljs-comment">// 将数组传入指针参数</span><br>        <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">test_point</span>(str);<br>    &#125;<br>    &#123;<span class="hljs-comment">// 将指针传入数组参数</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">test_arr</span>(str,<span class="hljs-number">6</span>);<br>    &#125;<br>    &#123;<br>        <span class="hljs-comment">//将数组传入数组参数</span><br>        <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-built_in">test_arr</span>(str,<span class="hljs-number">6</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[c++随笔]const、static、virtual</title>
    <link href="/2024/12/18/C-%E9%9A%8F%E7%AC%94%EF%BC%9Aconst%E3%80%81static%E3%80%81virtual/"/>
    <url>/2024/12/18/C-%E9%9A%8F%E7%AC%94%EF%BC%9Aconst%E3%80%81static%E3%80%81virtual/</url>
    
    <content type="html"><![CDATA[<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>static用于控制存储方式以及可见性，总的来说他的修饰可分为两大类<br><strong>普通修饰：局部变量、全局变量、函数<br>成员修饰：成员变量、成员函数</strong></p><p>1.修饰局部变量。<br>&ensp;&ensp;我们知道局部变量的生命周期就在其所定义的那个局部范围内，如某个函数，某个循环，一旦走出这个范围局部变量将自动释放。static修饰局部变量时，将改变变量的生命周期，实际上就是将其存储区域由原来的栈区移至静态区，使其<strong>生命周期与程序一样长</strong>。but，它的<strong>作用域并没有被改变</strong>，任然只能在局部的方位内使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//code</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>a++;<br>cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br>调用两次func,得到的结果分别是<span class="hljs-number">1</span>、<span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p>2.修饰全局变量与函数<br>&ensp;&ensp;static修饰全局变量与函数呈现的效果是一样的，即<strong>改变了修饰对象的作用域</strong>（由整个程序到当前文件），只能在定义它的源文件内使用。</p><p>3.修饰成员变量<br>&ensp;&ensp;静态成员变量由于存储在静态区,在程序开始时就必须存在，因而有不能在类中定义，只初始化一次（默认为0）等特点。</p><p>&ensp;&ensp;因为存储在静态区内，<strong>相当于一个全局变量</strong>，为所有类对象共有(相当于实现了类对象的数据共享)，但并没有包含在具体的类对象中，<font color=red>因此多添加一个静态成员不会影响sizeof()对类对象的计算值大小。<br>&ensp;&ensp;static修饰成员变量，必须初始化，必须在类外初始化，且不能再加static</p><p>访问方式：类名：：静态成员变量名、类对象名.静态成员变量名</p><p>4.修饰成员函数<br>静态成员函数不能访问非静态成员.也不能被const修饰<br>为什么静态成员函数只能访问静态成员?<br>&ensp;&ensp;因为<strong>静态成员函数没有this指针</strong>,试想,一个成员函数是通过this指针来确定当前类对象的,这样才能找到类对象中的成员.可是如果没有这个指针,函数就找不到这些普通成员,也就无从调用了.</p><p>&ensp;&ensp;那么为什么会没有this指针呢?我们从内存上来想想,因为static将成员存储在了静态区,在类加载时就会分配内存,这个过程在类对象创建之前,this是指向类对象的那么其创建过程也应该在这之后,所以静态函数存在时是没有this指针的.当然简单点也可以这么想，<strong>静态成员是属于类而不是专属某个类对象的</strong>，因此不该拥有this来将它的作用范围限定在类对象中。</p><p>&ensp;&ensp;通过上面的解释也能很好理解了，为什么静态成员函数不能被const修饰，以及为什么非静态成员函数能调用静态成员。const修饰成员函数的实质其实是修饰函数的隐藏参数this,准确来说是A * const this,既然静态成员函数没有this,也就没有办法用const修饰了。而静态成员函数被所有类对象共享,那么类对象的非静态成员函数自然能调用静态成员。<br>&ensp;&ensp;请注意“不属于类对象，但被类对象所共享”这句话的理解。<br>&nbsp;<br>&nbsp;</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><strong>const修饰分为：修饰指针，修饰参数，修饰成员函数</strong></p><p>1.关于修饰指针时的变与不变：<font color=red>const是一个左结合修饰符<font color=black><br>const int * a   ——–&gt;  const  (int *a)  修饰的是 *a 即a指针指向地址中的内容&#x2F;值不可变<br>int * const a   ——–&gt;  (int * const) a  修饰的是 a 即a指针指向的地址不可变</p><p><font color=blue>记法：const在前值(二声)不变，const在后址(三声)不变。<font color=black><br>这里的前后指的是  * 。</p><p>2.修饰参数<br>const修饰参数，表示该参数在函数中不能被改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span></span>; <span class="hljs-comment">//const保护A类对象的成员不被改变，引用传递是为了避免拷贝，提高效率。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>; <span class="hljs-comment">//无意义，这里是值传递方式，无论使用const与否，形参本就无法改变实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> * <span class="hljs-type">const</span> a)</span></span>;  <span class="hljs-comment">//int* a 作为形参传递，const修饰a 无法保护实参指向的内容。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * a)</span></span>; <span class="hljs-comment">//可保护a的值不被改变</span><br></code></pre></td></tr></table></figure><p>这里简单复习下值传递、指针传递、以及引用传递的区别：<br>&ensp;值传递为实参拷贝一个副本，即形参传递到函数中，任何对形参的修改都不会改变实参；<br>&ensp;指针传递本质上也是值传递，不过指针作为参数，传递的是指针的值，即地址。也就是说重新生成了一个形参指针，这个指针与实参指针指向同一片内存。这样一来，虽然改变形参无法改变实参指向的地址，却可以通过形参指针改变实参指针指向的地址中的内容。<br>&ensp;引用传递则是完全传入的是一个实参。</p><p>3.修饰成员函数<br>描述：<br>[1]const修饰成员函数后，该成员函数无法对成员变量进行修改；<br>[2]任何不修改成员变量的的成员函数都应该设为const；<br>[3]const成员函数不能调用非const成员函数；<br>写法：<br>const写在成员函数最后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>&ensp;写在这里的意义是修饰了成员函数中隐藏的this指针：A * const  this   ——&gt;const A * const this<br>可以看出const 修饰的是 *this 即this所指向的类。那么类中的内容（成员）就无法被改变了。<br>&ensp;这也能说明const成员函数无法调用非const成员函数这一特性，因为二者this指针已经不兼容了。不兼容的深层次一点的原因还要后面再研究下，不过从上面的描述我们可以简单推理然后记住这个特点，因为如果我们严格执行了描述[2]，那么没有加const的成员函数默认就是要修改成员的，此时const成员函数调用了它，则与描述[1]违背。</p><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p><strong>virtual用于修饰：成员函数（虚函数），继承方式（虚继承）</strong></p><p>1.修饰成员函数：<br>&ensp;<font color=red>父类指针指向子类对象，此时必须用到virtual来实现多态。<font color=black><br>&ensp;父类中定义虚函数，在子类中对该函数进行重写，此时父类指针调用时则会根据具体指向的子类对象来调用相应函数。当然，如果子类没有重写父类虚函数，则任然调用父类虚函数。父类中设置为virtual后子类中的同名函数均已经是为virtual，可不再添加修饰符。</p><p>&ensp;一般在使用这种多态方式时，需要将父类析构函数设为虚函数，否则在释放父类指针时将不会调用到子类析构，这很危险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss B create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br>A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-comment">//调用结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> destroy<span class="hljs-comment">//直接调用到父类析构，子类被跳过</span><br></code></pre></td></tr></table></figure><p>&ensp;当类中含有虚函数时（无论是自己的还是继承来的），<strong>编译器</strong>就会为每个类添加一个虚函数表，并用一个隐藏的虚表指针指向虚表（可以用sizeof（）看到，拥有虚函数的类对象会多出4字节的长度，就是这个虚表指针）。</p><p>&ensp;问：为什么virtua不能修饰静态成员函数？<br>&ensp;通过上面的解释，我们可以看出一个类对象要调用虚函数需要：先找到类对象的this指针访问到虚表指针，通过虚表指针找到虚函数才能调用，static成员函数没有this指针，也就不能调用到虚函数。因此，这两个修饰符不能用在一起。</p><p>2.修饰继承方式<br>虚继承简单提下，是用于解决菱形继承二义性的。</p><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><p>内容仍有待完善，欢迎大佬指正！</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
