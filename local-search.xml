<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[C++随笔：const、static、virtual]</title>
    <link href="/2024/12/18/C-%E9%9A%8F%E7%AC%94%EF%BC%9Aconst%E3%80%81static%E3%80%81virtual/"/>
    <url>/2024/12/18/C-%E9%9A%8F%E7%AC%94%EF%BC%9Aconst%E3%80%81static%E3%80%81virtual/</url>
    
    <content type="html"><![CDATA[<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>static用于控制存储方式以及可见性，总的来说他的修饰可分为两大类<br><strong>普通修饰：局部变量、全局变量、函数<br>成员修饰：成员变量、成员函数</strong></p><p>1.修饰局部变量。<br>&ensp;&ensp;我们知道局部变量的生命周期就在其所定义的那个局部范围内，如某个函数，某个循环，一旦走出这个范围局部变量将自动释放。static修饰局部变量时，将改变变量的生命周期，实际上就是将其存储区域由原来的栈区移至静态区，使其<strong>生命周期与程序一样长</strong>。but，它的<strong>作用域并没有被改变</strong>，任然只能在局部的方位内使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//code</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>a++;<br>cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br>调用两次func,得到的结果分别是<span class="hljs-number">1</span>、<span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p>2.修饰全局变量与函数<br>&ensp;&ensp;static修饰全局变量与函数呈现的效果是一样的，即<strong>改变了修饰对象的作用域</strong>（由整个程序到当前文件），只能在定义它的源文件内使用。</p><p>3.修饰成员变量<br>&ensp;&ensp;静态成员变量由于存储在静态区,在程序开始时就必须存在，因而有不能在类中定义，只初始化一次（默认为0）等特点。</p><p>&ensp;&ensp;因为存储在静态区内，<strong>相当于一个全局变量</strong>，为所有类对象共有(相当于实现了类对象的数据共享)，但并没有包含在具体的类对象中，<font color=red>因此多添加一个静态成员不会影响sizeof()对类对象的计算值大小。<br>&ensp;&ensp;static修饰成员变量，必须初始化，必须在类外初始化，且不能再加static</p><p>访问方式：类名：：静态成员变量名、类对象名.静态成员变量名</p><p>4.修饰成员函数<br>静态成员函数不能访问非静态成员.也不能被const修饰<br>为什么静态成员函数只能访问静态成员?<br>&ensp;&ensp;因为<strong>静态成员函数没有this指针</strong>,试想,一个成员函数是通过this指针来确定当前类对象的,这样才能找到类对象中的成员.可是如果没有这个指针,函数就找不到这些普通成员,也就无从调用了.</p><p>&ensp;&ensp;那么为什么会没有this指针呢?我们从内存上来想想,因为static将成员存储在了静态区,在类加载时就会分配内存,这个过程在类对象创建之前,this是指向类对象的那么其创建过程也应该在这之后,所以静态函数存在时是没有this指针的.当然简单点也可以这么想，<strong>静态成员是属于类而不是专属某个类对象的</strong>，因此不该拥有this来将它的作用范围限定在类对象中。</p><p>&ensp;&ensp;通过上面的解释也能很好理解了，为什么静态成员函数不能被const修饰，以及为什么非静态成员函数能调用静态成员。const修饰成员函数的实质其实是修饰函数的隐藏参数this,准确来说是A * const this,既然静态成员函数没有this,也就没有办法用const修饰了。而静态成员函数被所有类对象共享,那么类对象的非静态成员函数自然能调用静态成员。<br>&ensp;&ensp;请注意“不属于类对象，但被类对象所共享”这句话的理解。<br>&nbsp;<br>&nbsp;</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><strong>const修饰分为：修饰指针，修饰参数，修饰成员函数</strong></p><p>1.关于修饰指针时的变与不变：<font color=red>const是一个左结合修饰符<font color=black><br>const int * a   ——–&gt;  const  (int *a)  修饰的是 *a 即a指针指向地址中的内容&#x2F;值不可变<br>int * const a   ——–&gt;  (int * const) a  修饰的是 a 即a指针指向的地址不可变</p><p><font color=blue>记法：const在前值(二声)不变，const在后址(三声)不变。<font color=black><br>这里的前后指的是  * 。</p><p>2.修饰参数<br>const修饰参数，表示该参数在函数中不能被改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span></span>; <span class="hljs-comment">//const保护A类对象的成员不被改变，引用传递是为了避免拷贝，提高效率。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>; <span class="hljs-comment">//无意义，这里是值传递方式，无论使用const与否，形参本就无法改变实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> * <span class="hljs-type">const</span> a)</span></span>;  <span class="hljs-comment">//int* a 作为形参传递，const修饰a 无法保护实参指向的内容。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * a)</span></span>; <span class="hljs-comment">//可保护a的值不被改变</span><br></code></pre></td></tr></table></figure><p>这里简单复习下值传递、指针传递、以及引用传递的区别：<br>&ensp;值传递为实参拷贝一个副本，即形参传递到函数中，任何对形参的修改都不会改变实参；<br>&ensp;指针传递本质上也是值传递，不过指针作为参数，传递的是指针的值，即地址。也就是说重新生成了一个形参指针，这个指针与实参指针指向同一片内存。这样一来，虽然改变形参无法改变实参指向的地址，却可以通过形参指针改变实参指针指向的地址中的内容。<br>&ensp;引用传递则是完全传入的是一个实参。</p><p>3.修饰成员函数<br>描述：<br>[1]const修饰成员函数后，该成员函数无法对成员变量进行修改；<br>[2]任何不修改成员变量的的成员函数都应该设为const；<br>[3]const成员函数不能调用非const成员函数；<br>写法：<br>const写在成员函数最后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>&ensp;写在这里的意义是修饰了成员函数中隐藏的this指针：A * const  this   ——&gt;const A * const this<br>可以看出const 修饰的是 *this 即this所指向的类。那么类中的内容（成员）就无法被改变了。<br>&ensp;这也能说明const成员函数无法调用非const成员函数这一特性，因为二者this指针已经不兼容了。不兼容的深层次一点的原因还要后面再研究下，不过从上面的描述我们可以简单推理然后记住这个特点，因为如果我们严格执行了描述[2]，那么没有加const的成员函数默认就是要修改成员的，此时const成员函数调用了它，则与描述[1]违背。</p><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p><strong>virtual用于修饰：成员函数（虚函数），继承方式（虚继承）</strong></p><p>1.修饰成员函数：<br>&ensp;<font color=red>父类指针指向子类对象，此时必须用到virtual来实现多态。<font color=black><br>&ensp;父类中定义虚函数，在子类中对该函数进行重写，此时父类指针调用时则会根据具体指向的子类对象来调用相应函数。当然，如果子类没有重写父类虚函数，则任然调用父类虚函数。父类中设置为virtual后子类中的同名函数均已经是为virtual，可不再添加修饰符。</p><p>&ensp;一般在使用这种多态方式时，需要将父类析构函数设为虚函数，否则在释放父类指针时将不会调用到子类析构，这很危险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss B create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br>A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-comment">//调用结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> destroy<span class="hljs-comment">//直接调用到父类析构，子类被跳过</span><br></code></pre></td></tr></table></figure><p>&ensp;当类中含有虚函数时（无论是自己的还是继承来的），<strong>编译器</strong>就会为每个类添加一个虚函数表，并用一个隐藏的虚表指针指向虚表（可以用sizeof（）看到，拥有虚函数的类对象会多出4字节的长度，就是这个虚表指针）。</p><p>&ensp;问：为什么virtua不能修饰静态成员函数？<br>&ensp;通过上面的解释，我们可以看出一个类对象要调用虚函数需要：先找到类对象的this指针访问到虚表指针，通过虚表指针找到虚函数才能调用，static成员函数没有this指针，也就不能调用到虚函数。因此，这两个修饰符不能用在一起。</p><p>2.修饰继承方式<br>虚继承简单提下，是用于解决菱形继承二义性的。</p><p>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</p><p>内容仍有待完善，欢迎大佬指正！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/18/hello-world/"/>
    <url>/2024/12/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
