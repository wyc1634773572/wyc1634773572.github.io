<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[刷题]全排列</title>
    <link href="/2025/02/09/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2025/02/09/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>目标是返回所有可能的排列，很自然想到可以这样来穷举：<br>以1开头：123, 132  即1 + [2,3]全排列<br>以2开头：213, 231  即2 + [1,3]全排列<br>以3开头：312, 321  即3 + [1,2]全排列<br>可见，每一轮选定数字都有很多种可能，即多阶段决策问题。这种问题一般使用动态规划和回溯来求解。动态规划多用于评估只有一个方案的结果，像这种需要得到所有方案的题，使用回溯算法。</p><p>画图：<br><img src="/image/traceback_model.png" alt="回溯模型，其实完成就是一棵树的深度优先遍历">  </p><p>关键点：<br>    - 遍历过程的中止条件：当所有数字都被选中时，即是遍历到叶子层时。可以使用一个变量记录当前处于哪个层次。<br>    - 每次选中一个数字，在这之后的分支中该数字就不可再选中了，因此需要一个办法来记录哪些数字是被选中的。<br>    - 回溯算法，关键是在撤回上一步时恢复成上一步的状态。因此中间会有一段对更新了的状态变量的”逆操作”</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">note</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtrace</span>(nums,note);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; note)</span></span>&#123;<br>        <span class="hljs-comment">//中止条件，这里直接使用存储数字的向量size来比较，可以省略一个记录层次的变量</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//选择元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//note为false时表示i索引还没有被选过</span><br>            <span class="hljs-keyword">if</span>(note[i] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-comment">//更新状态</span><br>                note[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-comment">//递归，进入下一层</span><br>                <span class="hljs-built_in">backtrace</span>(nums,note);<br>                <span class="hljs-comment">//回溯，之前更新过状态的逆过程</span><br>                path.<span class="hljs-built_in">pop_back</span>();<br>                note[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>多阶段决策问题,即每一轮会有多种选择的问题，首先考虑动态规划和回溯。</p></li><li><p>刚开始不熟练，回溯问题最好先画图考虑清楚过程，再编码。画图中来思考：</p><ol><li>分支如何产生？</li><li>题目需要的解在哪里？是叶子节点还是非叶子节点，还是根节点到叶子节点的路径？</li><li>哪些分支会产生不需要的解，产生重复的原因是什么，剪枝条件是什么？</li></ol></li><li><p>回溯几乎就是深度优先遍历的实现，除了使用常规的递归，也可以使用栈来实现。</p></li><li><p>回溯算法理解后就比较简单了，但很多问题比较难的点在于如何剪枝。因为回溯本身是一种穷举，因此很容易发生超时等问题。剪枝优化是重点。</p></li><li><p>和树的按层次遍历一样，回溯大多有固定模板，如果忘记了，可以回顾一下模板来使自己迅速进入笔试状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(...)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(中止条件)&#123;<br>        存放结果；<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(选择元素)&#123;<br>        更新状态；<br>        <span class="hljs-built_in">backtrace</span>();<br>        恢复状态；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[刷题]消灭怪物最大数量</title>
    <link href="/2025/01/13/%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <url>/2025/01/13/%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给定一个 下标从 0 开始 且大小为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：千米）。</p><p>怪物以 恒定 的速度走向城市。每个怪物的速度都以一个长度为 n 的整数数组 speed 表示，其中 speed[i] 是第 i 个怪物的速度（单位：千米&#x2F;分）。</p><p>你有一种武器，一旦充满电，就可以消灭 一个 怪物。但是，武器需要 一分钟 才能充电。武器在游戏开始时是充满电的状态，怪物从 第 0 分钟 时开始移动。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰好 在某一分钟开始时到达城市（距离表示为0），这也会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：dist &#x3D; [1,3,4], speed &#x3D; [1,1,1]<br>输出：3<br>解释：<br>第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br>第 1 分钟开始时，怪物的距离是 [X,2,3]，你消灭了第二个怪物。<br>第 3 分钟开始时，怪物的距离是 [X,X,2]，你消灭了第三个怪物。<br>所有 3 个怪物都可以被消灭。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>因为计算消灭数量的关键是时间，因此首先想到从两个输入数组计算出怪兽到达城市的时间，用一个数组来存储。  </li><li>为了能消灭最多的怪兽，我们最好的办法是每次消灭到达城市时间最少的怪兽(贪心思想)，因此可以将时间数组升序排序，然后按照索引号依次消灭即可。  </li><li>观察时间数组可以发现规律：只有当数组索引小于对应的数组元素时，该怪兽才能被成功消灭，一旦数组索引大于等于数组元素值，则代表按照索引依次消灭的方法下，该怪兽一定会到达城市。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">eg:<br>    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] 该时间数组条件下，可依次消灭所有怪兽<br>    [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] 此时在中间插入一个时间为<span class="hljs-number">2</span>的怪兽，推理可知索引号为<span class="hljs-number">2</span>的怪兽一定来不及消灭，此时的特点是索引号<span class="hljs-number">2</span>等于了元素值<span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eliminateMaximum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist, vector&lt;<span class="hljs-type">int</span>&gt;&amp; speed)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">time</span><span class="hljs-params">(dist.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dist.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">float</span>(dist[i])/<span class="hljs-built_in">float</span>(speed[i]));<br>            time[i] = tmp;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(time.<span class="hljs-built_in">begin</span>(), time.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;time.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= time[j])&#123;<br>                <span class="hljs-keyword">return</span> j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> time.<span class="hljs-built_in">size</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="自总结"><a href="#自总结" class="headerlink" title="自总结"></a>自总结</h2><ul><li>一个问题：时间数组的计算需要向上取整，ceil( )函数可以做到这一点，但是编写代码时是直接使用了ceil对dist&#x2F;speed的结果取整，由于int类型除法的结果本身就会向下取整，这个时候再使用ceil就毫无作用了，因此改进成了先将两个数组强转为float类型以避免向下取整，再使用ceil就可以获取正确结果。</li><li>如果不使用ceil：(dist[i] - 1) &#x2F; speed[i] + 1</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]右值引用相关</title>
    <link href="/2025/01/09/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%A4%E4%B8%89%E4%BA%8B/"/>
    <url>/2025/01/09/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%A4%E4%B8%89%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="右值与左值"><a href="#右值与左值" class="headerlink" title="右值与左值"></a>右值与左值</h2><p><font color=yellow>简单来说有内存地址的就是左值，没有则是右值。</font><br>c++中的变量只要完成定义就代表已经被分配内存,所以在代码中任何一个非临时的具名变量都是左值。<br>右值又分为纯右值和将亡值: </p><ul><li>纯右值<br>不具名的临时对象或字面值常量,通常用于初始化对象,或者作为函数参数.<ul><li>int a &#x3D; 5;  字面量5是纯右值</li><li>double b &#x3D; sin(0.7);  sin()返回值是纯右值</li></ul></li><li>将亡值<br>即将被销毁的对象的值,通常出现在移动语义中,表示资源可以被转移.  <ul><li>std::move(a);<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">|值类型     是否临时     是否占内存 |<br>|----------------------------------<br>|左值            否            是  |<br>|----------------------------------<br>|纯右值          是            否  |<br>|----------------------------------<br>|将亡值          是            是  |<br>|----------------------------------<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul><li>左值引用(&amp;)一般都被认为是给左值变量取别名,引用变量与原来的变量其实是同一个东西，并不存在拷贝。  </li><li>右值引用(&amp;&amp;)其实是一样的，只不过对象变成了右值。右值被关联到右值引用后，因为引用变量本身是个左值，导致该右值也被存储了，此时该右值是非临时、具有内存的。 </li><li>一个易混淆点：左值引用只能绑定左值，右值引用只能绑定右值。<font color=yellow>但是常量左值引用却不一样，它既能绑定左值，常量左值以及右值！</font>因此我们可以看到，一般拷贝函数用的都是常量左值引用传参，在没有移动构造的情况下，传入右值也能触发拷贝构造。</li><li>右值引用一般都是为了转移资源，即用于移动语义和完美转发。</li></ul><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动语义旨在提升和对象相关操作的性能和效率，<font color=yellow>通过移动资源而不是拷贝资源</font>，实现了更有效的资源管理。要使用移动语义，必须先实现相应的移动构造&#x2F;移动赋值函数(以右值引用作为传参的构造函数)。调用时，一般使用std::move将左值强转为右值来传参，被强转的左值虽然依然能访问，但不应该对其结果抱有任何期待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拷贝构造函数（深拷贝）</span><br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> MyString&amp; other) <br>    &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(other.data) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data, other.data);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数调用，复制资源：&quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br> <br>    <span class="hljs-comment">// 移动构造函数（右值引用）</span><br>    <span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>    &#123;<br>        data = other.data;  <span class="hljs-comment">// 直接“偷取”资源</span><br>        other.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 清空源对象的指针</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数调用，转移资源：&quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br></code></pre></td></tr></table></figure><p>说到底为什么要有这种移动方案，因为函数调用不可避免地会开新的函数栈，在值传参和值返回的过程中必然会产生临时变量(因为函数返回会回到调用栈中，因此会用当前栈中的变量复制到调用栈，所以产生两个变量。当前栈的变量在函数返回后，出了作用域，因此立马结束生命周期。调用栈的副本，在表达式之后便死亡，只临时地活着。)<br>临时变量的资源不利用的话也是浪费，因为他只存在那么短的时间，复制他还花费了这么多时间，所以为了将他利用起来才有了利用右值和移动语义来转移资源的办法。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>完美转发旨在将参数保持原始类型属性地传到另一个函数，一般使用万能引用和std::forward来实现。</p><ul><li>万能引用( T&amp;&amp; arg )可以接受任何类型的参数(左值右值)</li><li>std::forward&lt;T&gt;(arg) 保持输入参数的类型属性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">( T  &amp;&amp;arg )</span> </span>&#123;<span class="hljs-comment">// T&amp;&amp;  万能引用</span><br><span class="hljs-built_in">dosomething</span>( std::forward&lt;T&gt;(arg) )<span class="hljs-comment">//forward 保持参数的值属性,不使用时，所有传入值均被当作左值处理。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; arg)</span></span>&#123;&#125;<span class="hljs-comment">//处理左值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp; arg)</span></span>&#123;&#125;<span class="hljs-comment">//处理右值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a);<span class="hljs-comment">//调用左值函数</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用右值函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>引用</tag>
      
      <tag>右值</tag>
      
      <tag>移动语义</tag>
      
      <tag>完美转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gtest</title>
    <link href="/2025/01/09/Gtest/"/>
    <url>/2025/01/09/Gtest/</url>
    
    <content type="html"><![CDATA[<h2 id="根据Cmake搭建Gtest框架"><a href="#根据Cmake搭建Gtest框架" class="headerlink" title="根据Cmake搭建Gtest框架"></a>根据Cmake搭建Gtest框架</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#设置c++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment">#包含FetchContent模块，用于从外部获取依赖项</span><br><span class="hljs-keyword">include</span>(FetchContent)<br>FetchContent_Declare(<br>    googleTest<br>    URL https://github.com/google/googletest/archive/<span class="hljs-number">03597</span>a01ee50ed33e9dfd640b249b4be3799d395.zip<br>)<br>FetchContent_MakeAvailable(googleTest)<br><br><span class="hljs-comment">#启用test</span><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-comment">#添加源文件</span><br><span class="hljs-keyword">add_executable</span>(<br>    mytest<br>    <span class="hljs-comment">#这里是依赖的源文件</span><br>    <span class="hljs-variable">$&#123;SRC_LIST&#125;</span><br>    <span class="hljs-comment">#以下是测试文件</span><br>    <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/../<span class="hljs-keyword">test</span>/cmenu_interface_test.cpp<br>    <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/../<span class="hljs-keyword">test</span>/caddress_interface_test.cpp<br>)<br><br><span class="hljs-comment">#链接主要的静态库gtest_main.a</span><br><span class="hljs-keyword">target_link_libraries</span>(<br>    mytest<br>    GTest::gtest_main<br>)<br><br><span class="hljs-comment">#包含googletest，并自动添加测试</span><br><span class="hljs-keyword">include</span>(GoogleTest)<br>gtest_discover_tests(mytest)<br></code></pre></td></tr></table></figure><p>测试文件，如上例中的cmenu_interface_test.cpp，需要#include &lt;gtest&#x2F;gtest.h&gt;，然后使用测试宏编写单元测试。</p><h2 id="GTest测试宏"><a href="#GTest测试宏" class="headerlink" title="GTest测试宏"></a>GTest测试宏</h2><h3 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a><font color=yellow>TEST</font></h3><p>使用 TEST宏来定义和命名一个测试函数。这是普通的 C++ 函数，不返回任何值。<br>在这个函数中，除了想包含的有效的 C++ 语句，还要使用各种 gtest 断言来检查值。<br>测试结果由断言确定；如果测试中的任何断言失败（无论是致命还是非致命），或者测试崩溃，整个测试都将失败。否则成功。<br>在该宏中，两个参数可以随意命名，但为了方便在测试结果中识别，还是应该按照测试逻辑命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;gtest/gtest.h&gt;</span></span><br><br><span class="hljs-built_in">TEST</span>(testsuitname, test1)&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TEST-F"><a href="#TEST-F" class="headerlink" title="TEST_F"></a><font color=yellow>TEST_F</font></h3><p>在使用TEST宏时写测试时，有时会发现很多测试操作的是类似的数据，这时就可以使用TEST_F宏来使多个测试使用相同的数据。<br>注意点：</p><ul><li>必须从testing::Test派生一个类</li><li>TEST_F的第一个参数必须是该派生类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMytest</span> : <span class="hljs-keyword">public</span> testing::Test &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span>* pt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//构造</span><br>        pt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//析构</span><br>        <span class="hljs-keyword">delete</span> pt;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(CMytest, test1)&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(CMytest, test2)&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">//使用时，每个TEST_F都会在开始时调用SetUp，结束时使用TearDown。这样一来，就不必每次都手动配置数据pt了。</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="TEST-P"><a href="#TEST-P" class="headerlink" title="TEST_P"></a><font color=yellow>TEST_P</font></h3><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>ASSERT_*  致命断言，断言失败时，会中止当前TEST，转而执行下个TEST<br>EXPECT_*  非致命断言，断言失败时，继续执行当前TEST<br>gtest 提供了一系列断言，用于以各种方式验证代码的行为。可以检查布尔条件，基于关系运算符比较值，验证字符串值、浮点值等等。甚至还有一些断言可以通过提供自定义谓词来验证更复杂的状态，如下：  </p><p>EXPECT_TRUE<br>EXPECT_NE<br>EXPECT_STREQ<br>EXPECT_FLOAT_EQ<br>…</p>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[STL]String</title>
    <link href="/2025/01/07/STL-String/"/>
    <url>/2025/01/07/STL-String/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>在C语言中，字符串是以’\0’结尾的一些字符的集合，但对这些字符串的操作需要依靠一系列str库函数，操作对象与操作方法是分离的。这不太符合面向对象的思想，于是C++中引入了String类。它是一个管理字符串的数据结构。  </p></li><li><p>string本质上是一个类，是c++用来代替char数组的数据结构，内部封装了char*。其空间大小如同vector一样是动态变化的。</p></li><li><p>string的接口与常规容器接口基本相同，另外再添加了一些操作string的常规方法。</p></li></ol><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><ol><li><font color = yellow>string();</font> 构造一个空字符串</li><li><font color = yellow>string(const char* s);</font></li><li><font color = yellow>string(const string&amp; str);</font></li><li><font color = yellow>string(const string&amp; str, size_t pos, size_t len &#x3D; npos);</font></li><li><font color = yellow>string&amp; operator&#x3D; (const &amp; string);</font></li><li><font color = yellow>string&amp; operator&#x3D; (const char* s);</font></li><li><font color = yellow>string&amp; operator&#x3D; (char c);</font></li></ol><h2 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h2><ol><li>访问操作<ul><li><font color = yellow>int operator [ ]</font>  返回指定位置的字符</li><li><font color = yellow>int at(pos)</font> 返回指定位置的字符</li><li><font color = yellow>iterator begin()</font></li><li><font color = yellow>iterator end()</font></li><li><font color = yellow>范围for</font>  必须具有迭代器的容器才能使用范围for：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : str) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>容量操作<ul><li><font color = yellow>size_t size()</font> 返回元素(字符)数量</li><li><font color = yellow>size_t capacity()</font> 返回分配的空间大小</li><li><font color = yellow>void clear()</font> 清空所有字符</li><li><font color = yellow>bool empty()</font> 检查字符串是否为空</li><li><font color = yellow>reverse(size_t n)</font> 重新分配空间</li><li><font color = yellow>resize(size_t n)</font> 重新设定元素数量</li></ul></li><li>增删改查<ul><li><font color = yellow>void push_back(char c)</font> 字符串后追加一个字符</li><li><font color = yellow>string&amp; append(const string&amp; str)</font> 字符串后面追加一个字符串</li><li><font color = yellow>void pop_back()</font> 弹出最后一个字符</li><li><font color = yellow>string&amp; operator+&#x3D;(const string&amp; str)</font> 字符串拼接</li><li><font color = yellow>string&amp; insert(size_t pos, const string&amp; str)</font> 在pos位置插入字符串</li><li><font color = yellow>string&amp; assign(const string&amp; str)</font> 将字符串重新赋值为str</li><li><font color = yellow>string&amp; erase(size_t pos&#x3D;0, size_t len&#x3D;npos)</font> 从pos开始删除len个字符</li><li><font color = yellow>void swap(string&amp; str)</font> 交换两个字符串</li></ul></li><li>其他操作<ul><li><font color = yellow>const char* c_str()</font> 获取等效的const char* 字符串</li><li><font color = yellow>string substr(size_t pos&#x3D;0, size_t len&#x3D;npos)</font> 从pos开始截取len个字符的子串</li><li><font color = yellow>size_t find(const string&amp; str, size_t pos&#x3D;0)</font> 从pos开始查找str子串第一次出现的位置</li></ul></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>-上述方法中，凡是涉及到参数const string&amp; str的方法，基本上都有另外一种const char* 参数和迭代器参数的重载，例如：  </p><p><font color = yellow>string&amp; assign(const string&amp; str)</font><br><font color = yellow>string&amp; assign(const char* s)</font><br><font color = yellow>string&amp; assign(iterator first, iterator last)</font></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake</title>
    <link href="/2025/01/05/Cmake/"/>
    <url>/2025/01/05/Cmake/</url>
    
    <content type="html"><![CDATA[<h2 id="Cmake语法"><a href="#Cmake语法" class="headerlink" title="Cmake语法"></a>Cmake语法</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)  <br><span class="hljs-keyword">project</span>(xxx)<br><br><span class="hljs-comment">#设置源文件与头文件变量，以及可执行文件输出位置</span><br><span class="hljs-keyword">set</span>(SOURCEDIR <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/src)<br><span class="hljs-keyword">set</span>(INCLUDEDIR  <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/..)<br><br><span class="hljs-comment">#设置头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;INCLUDEDIR&#125;</span>)<br><br><span class="hljs-comment">#将源文件路径中所有文件添加到变量中，注意这里只适用于多个源文件情况</span><br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;SOURCEDIR&#125;</span> SRC_LIST)<br><br><span class="hljs-comment">#生成libxyz.so</span><br><span class="hljs-keyword">add_library</span>(xyz SHARED <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><br><span class="hljs-keyword">set</span>(SOURCE<br>    main.cpp<br>    <span class="hljs-variable">$&#123;SRC_LIST&#125;</span><br>)<br><br><span class="hljs-comment">#生成可执行文件aaa</span><br><span class="hljs-keyword">add_executable</span>(aaa <span class="hljs-variable">$&#123;SOURCE&#125;</span>)<br><br><span class="hljs-comment">#动态链接xyz</span><br><span class="hljs-keyword">target_link_libraries</span>(aaa xyz)<br></code></pre></td></tr></table></figure><h2 id="Cmake执行"><a href="#Cmake执行" class="headerlink" title="Cmake执行"></a>Cmake执行</h2><p><font color=yellow>cmake -S . -B build</font> ：  通知Cmake在当前目录寻找CMakeLists.txt文件，在build目录下<font color=yellow>生成构建系统文件</font><br><font color=yellow>cmake –build build</font> ： 通知Cmake到build目录执<font color=yellow>行构建操作</font>，生成可执行文件或者是库文件<br><font color=yellow>make</font> ： 也可以到包含有构建系统文件的目录执行make命令，同样会发起构建</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol><li><font color=purple>PROJECT_BINARY_DIR</font>是cmake系统变量，表示执行camke构建命令的目录，而不是项目根目录，因为误解该变量含义导致make编译时引发了头文件未定义的错误。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[STL]Map</title>
    <link href="/2025/01/04/STL-Map/"/>
    <url>/2025/01/04/STL-Map/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>map是关联容器,关联容器中的元素是通过题目的键引用的，而不是通过他们在容器中的绝对位置引用的。即<font color = yellow>使用键key来索引，值value才是真正存储的数据。</font>  </p></li><li><p>map容器存储的都是piar对象，也就是用pair类模板创建的<font color = red>键值对</font>，使用map容器存储的键的值既不能重复也不能被修改，更确切地说map中所存储的其实是<font color = red>pair&lt;const K, V&gt;</font>， 同时也会根据键的值对所有键值对进行排序。  </p></li><li><p>底层实现是红黑树。优点是可以根据key值快速找到value值。</p></li></ol><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>因为map中存储的是pair类型，所以应该先了解pair类型的构造方式：  </p><ul><li>pair&lt;T1,T2&gt; p(V1, V2);</li><li>pair&lt;T1,T2&gt; p &#x3D; make_pair(V1, V2);</li><li>访问内容：pair.first &amp; pair.second</li></ul><p>map容器模板定义：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">key</span>,                                        <span class="hljs-comment">//键类型</span><br>          <span class="hljs-keyword">class</span> <span class="hljs-title class_">value</span>,                                      <span class="hljs-comment">//值类型</span><br>          <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;key&gt;,                        <span class="hljs-comment">//排序规则</span><br>          <span class="hljs-keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="hljs-type">const</span> K, V&gt;&gt;         <span class="hljs-comment">//分配器类型</span><br>          &gt; <span class="hljs-keyword">class</span> map;<br></code></pre></td></tr></table></figure><p>构造map的方式：  </p><ol><li><font color = yellow>map&lt;string, int&gt; mp;</font> 创建一个空map    </li><li><font color = yellow>map&lt;string, int&gt; mp{ { “xxx”, 1 }, { “yyy”, 2 } };</font>    注意这里不是括号  </li><li><font color = yellow>map&lt;string, int&gt; mp{ make_pair(“xxx”, 1), make_pair(“yyy”, 2) };</font></li><li><font color = yellow>map&lt;string, int&gt; mp( mp1 );</font>  拷贝构造</li><li><font color = yellow>map&lt;string, int&gt; mp( mp1.begin( ), mp1.end( ) );</font>  迭代器</li></ol><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><font color = yellow>at( key )</font>，获取key键对应的值，会进行下标检查，如果该键不存在，则抛出out_of_range异常</p></li><li><p><font color = yellow>count( key )</font>，统计键为key的元素个数</p></li><li><p><font color = yellow>size( )</font>，用于统计容器中元素个数</p></li><li><p><font color = yellow>empty( )</font>，判断容器是否为空</p></li><li><p><font color = yellow>begin( )</font>，获取容器中第一个键值对的迭代器</p></li><li><p><font color = yellow>end( )</font>，获取容器中最后一个键值对后一位的迭代器</p></li><li><p>增</p><ul><li><p><font color = yellow>pair&lt; iterator, bool &gt; insert( pair&lt;K, V&gt; )</font>，插入一个键值对，注意返回值是一个键值对<br>插入成功时，返回值的first指向插入成功的位置，second值为true<br>插入失败时，返回值的first指向已存在的键值对位置，second值为false<br>ps:插入函数可以指定插入位置，但之后容器会重新再排序。  </p></li><li><p><font color = yellow>pair&lt; iterator, bool &gt; emplace(Args&amp;&amp;… args)</font>，该函数会自动调用pair的构造函数，因此参数只需要传入pair所需的数据即可。该方法比insert效率更高，使用也更简单，因此应该尽量使用。</p></li><li><p><font color = yellow>[ ]</font>，当使用map[key]来访问key的键值对时，不会做下标检查，如果没有该键的键值对，则会自动增加该键的键值对到容器中。</p></li></ul></li><li><p>删</p><ul><li><font color = yellow>iterator erase( const iterator position )</font>，删除指定位置键值对，返回删除位置的下一个位置的迭代器。</li><li><font color = yellow>iterator erase( const iterator first, const iterator last )</font>，删除指定范围键值对</li><li><font color = yellow>size_type erase( cosnt key_type&amp; k )</font>，删除指定键的所有键值对</li><li><font color = yellow>void clear( )</font>， 删除所有元素</li></ul></li><li><p>改</p><ul><li><font color = yellow>mp.at[ key ] &#x3D; new_val;</font></li><li><font color = yellow>mp[ key ] &#x3D; new_val;</font></li></ul></li><li><p>查</p><ul><li><font color = yellow>itetator find( key )</font>，在容器中查找键值为key的键值对，若找到，返回指向该位置的迭代器，否则返回end( )位置迭代器。  </li><li><font color = yellow>lower_bound( key )</font>，返回第一个大于或等于key的键值对迭代器</li><li><font color = yellow>upper_bound( key )</font>，返回第一个大于key的键值对迭代器</li><li><font color = yellow>equal_range( key )</font>，返回一个pair对象，其中2个元素都是迭代器，first到second所表示的范围内都是键为key的键值对</li></ul></li></ul><h2 id="三种map"><a href="#三种map" class="headerlink" title="三种map"></a>三种map</h2><p>map (红黑树)：有序，键不能重复<br>multimap (红黑树)：有序，键能重复<br>unordered_map (哈希表)：无序，键不能重复  </p><p>插入、删除、查找时间复杂度：<br>map&#x2F;multimap O(log n)<br>unordered_map O( 1 )  </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[刷题]无重复字符的最长子串</title>
    <link href="/2025/01/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2025/01/02/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：s &#x3D; “abcabcbb”<br>输出：3  </p><p>输入：s &#x3D; “bbbbbb”<br>输出：1</p><p>输入：s &#x3D; “pwwkew”<br>输出：3  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拆解：</p><ol><li>如何遍历无重复子串？</li><li>如何判断有无重复</li><li>如何记录最大长度</li></ol><p>遍历无重复子串：滑动窗口<br>使用左右两个指针划定窗口范围，同时保证窗口中始终是无重复的子串。<br>因为要求最长子串，所以右指针向右移动，拓宽窗口长度，同时判断其指向的字符是否与窗口中的字符重复：  </p><ul><li>右指针与窗口中内容未发生重复，则继续右移</li><li>右指针与窗口中内容发生重复，左指针移动至窗口中重复字符的下一位 (保证窗口中无重复)</li></ul><p>直到右指针移动至字符串最后一位，结束窗口拓展。  </p><p>以示例来推导过程：<br>(a)bcabcbb<br>(ab)cabcbb<br>(abc)abcbb<br>a(bca)bcbb<br>ab(cab)cbb<br>abc(abc)bb<br>abcab(cb)b<br>abcabcb(b)  </p><p>边界条件，右指针第一次移动与最后一次移动。特殊情况，无字符串以及单字符字符串。</p><p>判断有无重复：直接循环遍历窗口中的字符<br>记录最大长度：典型方法，同一个变量反复替代。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(r &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//循环检查是否重复r位是否与之前重复</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;r;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == s[r])&#123;<br>                l = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        max = max &gt; r - l + <span class="hljs-number">1</span> ? max : r - l + <span class="hljs-number">1</span>;<br>        r++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自总结"><a href="#自总结" class="headerlink" title="自总结"></a>自总结</h2><ul><li>使用集合来检查重复，提高效率</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[刷题]将日期转换为二进制</title>
    <link href="/2025/01/01/%E5%B0%86%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <url>/2025/01/01/%E5%B0%86%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串data，它的格式为 yyyy-mm-dd, 表示一个公历日期。<br>date 可以重写为二进制表示，只需要将年、月、日分别转换为对应的二进制表示 (不带前导零) 并遵循year-mount-day的格式。<br>返回date的二进制表示。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入： date &#x3D; “2080-02-29”<br>输出： date &#x3D; “100000100000-10-11101”  </p><p>输入： date &#x3D; “1900-01-01”<br>输出： date &#x3D; “11101101100-1-1”</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>拆解：  </p><ol><li>提取字符串中的年月日字段</li><li>将年月日字段转化为对应数值</li><li>实现十进制到二进制转化</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">binaryval</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    string result;<br>    stack&lt;<span class="hljs-type">char</span>&gt; st;<br>    <span class="hljs-keyword">while</span>(val &gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tar = val % <span class="hljs-number">2</span>;<br>        val /= <span class="hljs-number">2</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;0&#x27;</span> + tar);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        result.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">convertDateToBinary</span><span class="hljs-params">(string date)</span> </span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>));<br>    <span class="hljs-type">int</span> month = <span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-type">int</span> day = <span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binaryval</span>(year) +<span class="hljs-string">&quot;-&quot;</span>+ <span class="hljs-built_in">binaryval</span>(month) +<span class="hljs-string">&quot;-&quot;</span>+ <span class="hljs-built_in">binaryval</span>(day);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自总结"><a href="#自总结" class="headerlink" title="自总结"></a>自总结</h2><ul><li>对string类的成员函数不够了解，容易浪费时间去实现已经造好的 ‘轮子’。因此应该重新熟悉string类的所有内容</li><li>在编码时区分int类型数值与char类型显示的关系耗费了大量时间，需要重新熟悉SACII码表，以及梳理两者转关系。</li><li>十进制转二进制的代码逻辑可以优化一版：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string str;<br><span class="hljs-keyword">while</span>(val &gt; <span class="hljs-number">0</span>)&#123;<br>    str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + (val &amp; <span class="hljs-number">1</span>));<br>    val &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">end</span>());<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]智能指针</title>
    <link href="/2024/12/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/12/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="用途与共性"><a href="#用途与共性" class="headerlink" title="用途与共性"></a>用途与共性</h1><p>智能指针用于更安全和方便地管理动态分配的资源，避免内存泄漏和悬空指针等问题。<br>实质：将指针托管到一个对象中，资源的创建与对象的构造绑定，资源的释放与对象的析构绑定。这样，当对象生命周期结束时则会自动调用析构，由此完成资源释放。 <font size=3 color=yellow>(RAII)</font>  </p><p>既然是对象，那么就有自己的成员方法，智能指针常用的方法有：</p><ol><li><font size=3 color=yellow>get( )</font>    获取智能指针托管的地址，返回指向该地址的裸指针</li><li><font size=3 color=yellow>reset( _Ty* _ptr &#x3D; nullptr )</font>   重置指针托管权，<font size=3 color=yellow>会释放以前被托管的内存，无返回</font>  </li><li>因为重载了<font size=3 color=yellow>*和-&gt;</font>  两个运算符，所以智能指针可以像普通指针那样使用。</li><li><font size=3 color=yellow>swap(Ty* _ptr)</font>  交换两个智能指针的托管内容</li></ol><p>ps：应该尽量避免智能指针和普通指针混合使用，容易造成泄漏和崩溃！</p><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>构造方式：  </p><ul><li><p>传统方式<br><font size=3 color=yellow>unique_ptr&lt;T&gt; p( new T( ) )</font>       </p></li><li><p>c++ 14<br><font size=3 color=yellow>unique_ptr&lt;T&gt; p &#x3D; make_unique&lt;T&gt;( )</font></p></li></ul><p>unique_ptr基于排他所有权模式，对动态分配的对象拥有唯一所有权，为了达到这一目的，禁止了普通拷贝与赋值，但可以通过std::move来转移资源所有权到另外一个unique_ptr中。实际是触发了它的移动构造。<br>常见转移所有权用法：</p><ul><li><font size=3 color=yellow>unique_ptr&lt;T&gt; p1 ( std::move( p ) );</font>  </li><li><font size=3 color=yellow>unique_ptr&lt;T&gt; p1 &#x3D; std::move( p );</font>  </li><li><font size=3 color=yellow>unique_ptr&lt;T&gt; p1( p.release( ) );</font>  </li><li><font size=3 color=yellow>p1.reset( p1.release( ) );</font></li></ul><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>构造方式：  </p><ul><li>传统方式<br><font size=3 color=yellow>shared_ptr&lt;T&gt; p( new T( ) )</font>  </li><li>c++ 14<br><font size=3 color=yellow>shared_ptr&lt;T&gt; p &#x3D; make_shared_ptr&lt;T&gt;( )</font></li></ul><p>成员方法：</p><ul><li><font size=3 color=yellow>use_count( )</font>   返回当前指针托管指针的引用计数</li><li>注意<font size=3 color=yellow>shared_ptr没有release( )</font>  方法</li></ul><p>shared_ptr是一种共享式的指针，多个指针可以可以指向同一个对象。内部采用引用计数的方式追踪引用数量，当计数为零时才会自动销毁托管对象。<br>该指针在引用计数采用了原子操作，因此其本身是线程安全的，但对其托管对象的操作则并不是。<br>引用增加：  </p><ul><li><font size=3 color=yellow>shared_ptr&lt;T&gt; p1 &#x3D; p;</font>    </li><li><font size=3 color=yellow>shared_ptr&lt;T&gt; p1( p );</font></li></ul><p>主动释放：</p><ul><li><font size=3 color=yellow>p1 &#x3D; nullptr;</font>  </li><li><font size=3 color=yellow>p1.reset( );</font></li></ul><p>shared_ptr最需要注意的一点需要小心<font size=3 color=red>循环引用</font>造成无法释放资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> _val;<br>    shared_ptr&lt;Node&gt; _next;<br><br>    ~<span class="hljs-built_in">Node</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用析构&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p1 = <span class="hljs-built_in">make_shared_ptr</span>&lt;Node&gt;();<br>    <span class="hljs-keyword">auto</span> p2 = <span class="hljs-built_in">make_shared_ptr</span>&lt;Node&gt;();<br><br>    p1-&gt;_next = p2;<br>    p2-&gt;_next = p1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例会发现最后并没有调用到析构函数，因为两个智能指针互相管理，导致引用最后无法减到0.<br>解决方法，Node内部采用weak_ptr.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/12/22/Git/"/>
    <url>/2024/12/22/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="参与已有项目-加入新工作"><a href="#参与已有项目-加入新工作" class="headerlink" title="参与已有项目(加入新工作)"></a>参与已有项目(加入新工作)</h2><p>初始化新的仓库<br><font color=yellow>git init</font></p><p>克隆远端仓库到本地<br><font color=yellow>git clone + &lt;ssh&#x2F;https&gt;</font>  </p><p>拉取到最新更改<br><font color=yellow>git pull</font></p><p>创建新的本地分支并切换过去(一般要避免直接修改main&#x2F;master分支，即基线)<br><font color=yellow>git checkout -b branch</font>  </p><p>代码更改完毕，加入暂存区<br><font color=yellow>git add  &lt;file&gt;</font></p><p>提交更改,添加提交信息<br><font color=yellow>git commit -s&#x2F;-m</font>  </p><p>推送branch分支的更改到远端仓库，此时远端仓库也会生成一个同名branch分支接收更改<br>这里的&lt;remote&gt;一般默认是origin，即指远端仓库<br><font color=yellow>git push -u &lt;remote&gt; branch</font><br>or<br><font color=yellow>git push origin HEAD : remote_branch</font>  </p><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p>查看提交历史<br><font color=yellow>git log</font>  </p><p>查看工作目录和暂存区状态<br><font color=yellow>git status</font></p><p>列出所有&#x2F;远端分支<br><font color=yellow>git branch -a&#x2F;-r</font></p><p>删除本地分支<br><font color=yellow>git branch -d &lt;local_branch&gt;</font></p><p>切换本地分支<br><font color=yellow>git checkout &lt;local_branch&gt;</font></p><p>查看本地分支与远端关联的情况<br><font color=yellow>git branch -vv</font></p><p>重置暂存区到上一个提交<br><font color=yellow>git reset  –soft&#x2F;–hard &lt;commit-id&gt;</font></p><p>查看提交具体更改<br><font color=yellow>git show &lt;commit-id&gt;</font></p><p>添加一个新的远程仓库，将其命名为 &lt;remote&gt;<br><font color=yellow>git remote add &lt;remote&gt; &lt;ssh&#x2F;https&gt;</font></p><p>查看远端仓库配置(即关联的远端仓库名和url地址等)<br><font color=yellow>git remote -v</font></p><p>查看远端仓库与本地仓库间的对应关系<br><font color=yellow>git remote show &lt;remote&gt;</font></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol><li><p>远端分支已经被删除，本地git branch -r 还是能看到<br>git remote show origin  可以看到远端仓库中被删除的分支状态为： stale(use ‘git remote prune’ to remove)<br>使用git remote prune origin 即可清理掉这些分支</p></li><li><p>新建了一个远端仓库，但不用clone方式来创建本地仓库  </p><ul><li><p>初始化：<br><font color=yellow>git init</font>  </p></li><li><p>完成第一笔提交：<br><font color=yellow>git add .</font><br><font color=yellow>git commit</font>  </p></li><li><p>添加远端仓库：<br><font color=yellow>git remote add origin &lt;ssh&#x2F;https&gt;</font>  </p></li><li><p>推送更新+关联主分支<br>如果本地主分支名字与加入的远端仓库主分支不同，则还需要改名：<br><font color=yellow>git push -u origin master</font></p></li></ul></li><li><p>git push 命令有无-u选项的区别是什么？<br>基本的推送指令是需要指定源分支与目标分支的：git push origin  &lt;local_branch&gt; : &lt;remote_branch&gt;<br>一般推送当前本地分支时，local_branch直接使用<font color=red>HEAD</font>就可以了。<br>-u选项是设置上游分支，即指定local分支与remote分支关联，以后直接使用git push 命令就能更新到远程。当没有指定remote分支时，会在远端自动生成一条很local分支同名的分支来进行关联。而指定了remote却没指定local时，指的是将本地空分支推到远端，起到的效果是<font color=red>删除了对应的远端分支。</font></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tool</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]面向对象三大特性</title>
    <link href="/2024/12/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2024/12/19/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对类的封装，将类成员变量私有化，提供公共的接口以访问成员变量，避免了外部函数直接访问，以达到封装的目的。<br>允许任何类或外部函数直接访问的设为 public<br>允许子类访问的设为 protected<br>只允许本类访问的设为 private  </p><p>protected与private单从一个类来看几乎没有区别，他们均不能被直接调用，而是要通过公共接口来访问。他们的明显区别要放到继承中才能得以体现，protected能被子类的公共接口直接调用，private不能被子类公共接口直接访问（除非子类接口调用了父类可访问该私有成员的公共接口）。  </p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><font color=red>继承是一个普遍到特殊的过程</font><br>因为子类会在父类原有功能的基础上进行扩展，不同的子类在保持了父类的一些相同特性后又会根据需要衍生出其他子类所没有的内容，因此父类看作是一个共性的集合体，而子类则是该集合体的一种特殊分支。  </p><p>以鸟类来举例，所有鸟类都具有相同的鸟类特征因此才会被归为鸟，而不同的鸟种又有不同的特点，如啄木鸟的特点是能啄木，企鹅的特点是不会飞等，这时鸟类作为父类，而啄木鸟企鹅等则是为子类。</p><p>类的继承有三种方式：共有继承，私有继承以及保护继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> B<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">private</span> B<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">protected</span> B<br></code></pre></td></tr></table></figure><p>下面这张表将展示三种继承后，父类的成员访问属性将发生何种变化：</p><table><thead><tr><th></th><th>父类 pubilc</th><th>父类 protected</th><th>父类 private</th></tr></thead><tbody><tr><td>公有继承</td><td>子类 public</td><td>子类 protected</td><td>父类 private</td></tr><tr><td>保护继承</td><td>子类 protected</td><td>子类 protected</td><td>父类 private</td></tr><tr><td>私有继承</td><td>子类 private</td><td>子类 private</td><td>父类 private</td></tr></tbody></table><p>注意上述父类private，不管哪种继承，父类私有始终是父类的私有，子类无法直接访问，需调用父类公有函数才能访问。而protected会变成子类的成员，此时子类的公有函数也能访问他了。这里就是封装中我们提到的二者的差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> Base_pub = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> Base_pro = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> Base_pri = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">show_Base_pub</span>()&#123;cout &lt;&lt; Base_pub;&#125;;<br><span class="hljs-built_in">show_Base_pro</span>()&#123;cout &lt;&lt; Base_pro;&#125;;<br><span class="hljs-built_in">show_Base_pri</span>()&#123;cout &lt;&lt; Base_pri;&#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">show_Child_pub</span>()&#123;cout &lt;&lt; Base_pub&#125;;<span class="hljs-comment">//合法</span><br><span class="hljs-built_in">show_Child_pro</span>()&#123;cout &lt;&lt; Base_pro&#125;;<span class="hljs-comment">//合法，Base_pro以及为子类的保护成员</span><br><span class="hljs-built_in">show_Child_pri</span>()&#123;cout &lt;&lt; Base_pri&#125;;<span class="hljs-comment">//非法，Base_pri仍然是父类私有属性</span><br><span class="hljs-built_in">show_Child_pri</span>()&#123;<span class="hljs-built_in">show_Base_pri</span>()&#125;;<span class="hljs-comment">//修改，调用父类公有函数，合法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>子类在创建以及销毁时，调用构造与析构的顺序严格如下：<br>父类构造—–》子类构造—–》子类析构—–》父类析构  </p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态也分静态多态以及动态多态；静态多态以重载和模板来实现，动态多态以虚函数方式来实现，当然这里最重要的无疑是动态多态，以下只讨论这种动态的方式。</p><p>C++多态的实现需要满足两个条件：<br>1.父类指针指向子类对象<br>2.调用的函数为虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base *base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();<br>base-&gt;<span class="hljs-built_in">virtual_fun</span>()<span class="hljs-comment">//此时调用的是子类的对应虚函数</span><br><br><span class="hljs-comment">//C++支持这种父类指针指向子类对象的操作，最常见的用法如下：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Base * b)</span></span>&#123; <span class="hljs-comment">/*函数体*/</span> &#125;<br>Child c;<br><span class="hljs-built_in">func</span>(&amp;c);<br><br><span class="hljs-comment">//上面这种写法更好地向初学者展示了何为多态，即我们通过一个写定的func接口，传入不同的对象参数就能做到不一样的处理逻辑了。很多设计模式都是采用这种写法完成多态的。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]virtual</title>
    <link href="/2024/12/19/virtual/"/>
    <url>/2024/12/19/virtual/</url>
    
    <content type="html"><![CDATA[<h1 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h1><p><strong>virtual用于修饰：成员函数（虚函数），继承方式（虚继承）</strong></p><ol><li><font size=3 color=yellow>修饰成员函数</font></li></ol><ul><li>定义虚函数与纯虚函数，实现多态  <ul><li><font color=red>父类指针指向子类对象，此时必须用到virtual来实现多态。</font>父类中定义虚函数，在子类中对该函数进行重写，此时父类指针调用时则会根据具体指向的子类对象来调用相应函数。当然，如果子类没有重写父类虚函数，则任然调用父类虚函数。虚函数相当于为子类提供一个了缺省实现，而纯虚函数则是必须由子类实现。  </li><li>父类中设置为virtual后子类中的同名函数均已经是为virtual，可不再添加修饰符。  </li><li>必须注意需要将父类析构函数设为虚函数，否则在释放父类指针时将不会调用到子类析构，这很危险。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss B create&quot;</span>&lt;&lt;endl;&#125;<br>~<span class="hljs-built_in">B</span>()&#123;cout&lt;&lt;<span class="hljs-string">&quot;calss A destroy&quot;</span>&lt;&lt;endl;&#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br>A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-comment">//调用结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> create<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> destroy<span class="hljs-comment">//直接调用到父类析构，子类被跳过</span><br></code></pre></td></tr></table></figure><ul><li>当类中含有虚函数时（无论是自己的还是继承来的），<strong>编译器</strong>就会为每个类添加一个虚函数表，并用一个隐藏的虚表指针指向虚表（可以用sizeof看到，拥有虚函数的类对象会多出4字节的长度，就是这个虚表指针）。</li></ul><p>Question：为什么virtua不能修饰static静态成员函数？<br>通过上面的解释，我们可以看出一个类对象要调用虚函数需要：先找到类对象的this指针访问到虚表指针，通过虚表指针找到虚函数才能调用，static成员函数没有this指针，也就不能调用到虚函数。因此，这两个修饰符不能用在一起。</p><p>Question：析构函数能设为虚函数，那构造函数不能设为虚函数？<br>不能，虚函数调用需要用到this指针，this指针又是在构造函数中创建的，如果构造函数设为虚函数，谁来创造this并调用构造?</p><ol start="2"><li>修饰继承方式<br>用于解决菱形继承二义性。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>static</tag>
      
      <tag>virtual</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]const</title>
    <link href="/2024/12/19/const/"/>
    <url>/2024/12/19/const/</url>
    
    <content type="html"><![CDATA[<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p><strong>const修饰分为：修饰指针，修饰参数，修饰成员函数</strong></p><ol><li><font size=3 color=yellow>修饰指针</font><br>这种情况一般要注意的是常量指针与指针常量：</li></ol><ul><li><p>常量指针，本质是个指针，指向一个常量：<br>const int * a   ——–&gt;  const  (int *a)  修饰的是 *a 即a指针指向地址中的内容&#x2F;值不可变    </p></li><li><p>指针常量，本质是个常量：<br>int * const a   ——–&gt;  (int * const) a  修饰的是 a 即a指针指向的地址不可变  </p></li><li><p><font color=red>const在前值不变，const在后址不变。</font><br>这里的前后指的是相对于  * 。</p></li></ul><ol start="2"><li><font size=3 color=yellow>修饰参数</font><br>const修饰参数，意指该函数不会改变该参数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span></span>; <span class="hljs-comment">//const保护A类对象的成员不被改变，引用传递是为了避免拷贝，提高效率。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>; <span class="hljs-comment">//无意义，这里是值传递方式，无论使用const与否，形参本就无法改变实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> * <span class="hljs-type">const</span> a)</span></span>; <span class="hljs-comment">//传入指针常量，无法改变形参指向地址，但能修改所指内容，无法保护a的内容。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * a)</span></span>; <span class="hljs-comment">//可保护a的内容不被改变</span><br></code></pre></td></tr></table></figure><p>这里简单提一下值传递、指针传递、以及引用传递的区别：  </p><ul><li>值传递为实参拷贝一个副本，即形参传递到函数中，任何对形参的修改都不会改变实参；  </li><li>指针传递本质上也是值传递，不过指针作为参数，传递的是指针的值，即地址。也就是说重新生成了一个形参指针，这个指针与实参指针指向同一片内存。这样一来，虽然改变形参无法改变实参指向的地址，却可以通过形参指针改变实参指针指向的地址中的内容。  </li><li>引用传递其实也是指针传递,在汇编代码中可以看出,指针传递和引用传递的汇编语句是一致的。</li></ul><ol start="3"><li><font size=3 color=yellow>修饰成员函数</font></li></ol><ul><li><p>写法：const写在成员函数最后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>const修饰成员函数后，该成员函数无法对成员变量进行修改；<br> 写在这里的意义是修饰了成员函数中隐藏的this指针：A * const  this   ——&gt;const A * const this<br> 可以看出const 修饰的是 *this 即this所指向的类对象。那么类对象中的内容（成员）就无法被改变了。 </p></li><li><p>const成员函数不能调用非const成员函数；  </p></li><li><p>任何不修改成员变量的的成员函数都应该设为const；</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>const</tag>
      
      <tag>参数传递</tag>
      
      <tag>引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++基础]static</title>
    <link href="/2024/12/18/static/"/>
    <url>/2024/12/18/static/</url>
    
    <content type="html"><![CDATA[<h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>static用于控制存储方式以及可见性，总的来说他的修饰可分为两大类<br><strong>普通修饰：局部变量、全局变量、函数</strong><br><strong>成员修饰：成员变量、成员函数</strong>  </p><ol><li><font size=3 color=yellow>修饰局部变量。</font></li></ol><ul><li>我们知道局部变量的生命周期就在其所定义的那个局部范围内，如某个函数，某个循环，一旦走出这个范围局部变量将自动释放。static修饰局部变量时，将改变变量的生命周期，实际上就是将其存储区域由原来的栈区移至静态区，使其<strong>生命周期与程序一样长</strong>。但是，它的<strong>作用域并没有被改变</strong>，任然只能在局部的方位内使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>a++;<br>cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br>调用两次func,得到的结果分别是<span class="hljs-number">1</span>、<span class="hljs-number">2</span>。说明出了作用域之后a的生命周期并没有结束<br></code></pre></td></tr></table></figure><ol start="2"><li><font size=3 color=yellow>修饰全局变量与函数</font></li></ol><ul><li>static修饰全局变量与函数呈现的效果是一样的，即<strong>改变了修饰对象的作用域</strong>（由整个程序到当前文件），只能在定义它的源文件内使用。</li></ul><ol start="3"><li><font size=3 color=yellow>修饰成员变量  </font></li></ol><ul><li><p>静态成员变量由于存储在静态区,在程序开始时就必须存在，因而有不能在类中定义，只初始化一次（默认为0）等特点。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;   <span class="hljs-comment">//只能声明</span><br>&#125;<br><span class="hljs-type">int</span> A::a = <span class="hljs-number">11</span>;     <span class="hljs-comment">//定义在类外，如果不赋值则默认给0</span><br></code></pre></td></tr></table></figure></li><li><p>因为存储在静态区内，<strong>相当于一个全局变量</strong>，为所有类对象共有(相当于实现了类对象的数据共享)，但并没有包含在具体的类对象中，<font color=red>因此多添加一个静态成员不会影响sizeof()对类对象的计算值大小。</font>  </p></li><li><p>static修饰成员变量，必须初始化，必须在类外初始化，且不能再加static</p></li><li><p>访问方式：类名：：静态成员变量名、类对象名 . 静态成员变量名</p></li></ul><ol start="4"><li><font size=3 color=yellow>修饰成员函数</font></li></ol><ul><li>静态成员函数不能访问非静态成员.也不能被const修饰  <ul><li><p>为什么静态成员函数只能访问静态成员?<br>因为<font color=red><strong>静态成员函数没有this指针</strong></font>,试想,一个成员函数是通过this指针来确定当前类对象的,这样才能找到类对象中的成员.可是如果没有这个指针,函数就找不到这些普通成员,也就无从调用了。  </p></li><li><p>那么为什么会没有this指针呢?我们从内存上来想想,因为static将成员存储在了静态区,在类加载时就会分配内存,这个过程在类对象创建之前,this是指向类对象的那么其创建过程也应该在这之后,所以静态函数存在时是没有this指针的。当然简单点来说，**<font color=red>静态成员是属于类而不是专属某个类对象的</font>**，因此不该拥有this来将它的作用范围限定在类对象中。  </p></li><li><p>通过上面的解释也能很好理解了，为什么静态成员函数不能被const修饰，以及为什么非静态成员函数能调用静态成员。const修饰成员函数的实质其实是修饰函数的隐藏参数this,准确来说是A * const this,既然静态成员函数没有this,也就没有办法用const修饰了。而静态成员函数被所有类对象共享,那么类对象的非静态成员函数自然能调用静态成员。请注意理解“不属于类对象，但被类对象所共享”。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>const</tag>
      
      <tag>static</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
